import {
    Box,
    Button,
    CircularProgress,
    Dialog, DialogActions,
    DialogContent,
    DialogTitle,
    FormControl,
    MenuItem,
    Stack,
    TextField,
    Typography
} from "@mui/material";
import {client_create_validate, client_edit_validate, RecordType} from "../schema";
import React, {useCallback, useEffect, useMemo, useState} from "react";
import _ from "lodash";
import {City, Country, ICity, ICountry, IState, State} from "country-state-city";
import {PhoneNumber, PhoneNumberFormat, PhoneNumberUtil} from "google-libphonenumber";
import InputMask from 'react-input-mask';
import {create_record, edit_record, TableData} from '../fetch';

type editSourceType = RecordType & {
    _phone?: PhoneNumber,
    _location?: [ICountry | undefined, IState | undefined, ICity | undefined],
};
type editRecordType = {
    name: string,
    phone: string,
    email: string,
    country: string,
    state?: string,
    city?: string,
};
type editRecordTypeKey = keyof editRecordType;

type createRecordType = editRecordType & {
    email2: string,
};
type createRecordKey = keyof createRecordType;

type createRecordErrType = {
    name: string,
    phone: string,
    email: string,
    email2: string,
    country: string,
    state: string,
    city: string,
    created: string,
    updated: string,
};

type RecordFormProps = {
    source?: Partial<editSourceType>,
    on_confirm: (x: TableData, type: 'create' | 'edit') => void,
};

type validateError = {
    path: keyof createRecordErrType,
    message: string,
};

const countries = Country.getAllCountries();

type DialogContentType = {
    type: 'loading' | 'error' | 'success',
    label: string,
    message?: string,
    on_success?: () => void;
};

export function RecordForm(props: RecordFormProps) {
    let {source, on_confirm} = props;
    const is_editing = useMemo(() => !_.isEmpty(source), [source]);
    const [pending, set_pending] = useState<Partial<createRecordType>>();
    const [errors, set_errors] = useState<Partial<createRecordErrType>>();
    const full_filled = useMemo(() => {
        if (!pending)
            return false;

        const all_keys: createRecordKey[] = ['phone', 'name', 'email', 'country'];
        if (!is_editing)
            all_keys.push('email2');
        const res = all_keys.every(x => !!pending?.[x]);
        return res;
    }, [pending]);
    const [dialog_content, set_dialog_content] = useState<DialogContentType>()

    useEffect(function set_from_source() {
        if (_.isEmpty(source))
            set_pending({});
        else {
            const upd = {
                ..._.pick(source, ['name', 'email', 'phone']),
                country: source._location?.[0]?.isoCode || source.country,
                state: source._location?.[1]?.isoCode || source.state,
                city: source._location?.[2]?.name || source.city,
            };
            console.log('Country:', upd.country);
            set_pending(upd);
        }
        set_errors({});
    }, [source]);
    useEffect(function validate() {
        if (!pending)
            return;

        const validate_fn = is_editing ? client_edit_validate : client_create_validate;
        const errors: Partial<createRecordErrType> = {};
        try {
            validate_fn({...pending}, full_filled);
        } catch (e: any & validateError) {
            if (e?.result) {
                // @ts-ignore
                errors[e.result.path] = e.result.message;
            }
        } finally {
            set_errors(errors);
        }
    }, [pending, full_filled]);

    const states = useMemo(() => State.getStatesOfCountry(pending?.country || '') || [],
        [pending?.country]);
    const cities = useMemo(() => City.getCitiesOfState(pending?.country || '', pending?.state || ''),
        [pending?.country, pending?.state]);
    const phone_mask = useMemo(() => {
        if (!pending?.country)
            return '';

        let util = PhoneNumberUtil.getInstance();
        // @ts-ignore
        if (!util.getSupportedRegions().includes(pending?.country))
            return '';

        const number = util.getExampleNumber(pending?.country || '');
        let format = util.format(number, PhoneNumberFormat.INTERNATIONAL);

        const country_code = '' + number.getCountryCode();
        let index = format.indexOf(country_code);
        if (index >= 0)
            index += country_code.length;
        const mask = format.substring(0, index).replace(/9/g, '\\9')
            + format.substring(index).replace(/\d/g, '9');
        return mask;
    }, [pending?.phone]);

    const can_apply = useMemo(() => {
        if (!full_filled || !_.isEmpty(errors))
            return false;

        const fields_to_compare = ['name', 'phone', 'email', 'email2', 'country', 'state', 'city',];
        const left = _.pick(source, fields_to_compare);
        const right = _.pick(pending, fields_to_compare);
        return !_.isEqual(left, right);
    }, [pending, errors, full_filled]);
    const change_field_fn = useCallback((prop: keyof createRecordType) => {
        return function (e: React.ChangeEvent<HTMLInputElement>) {
            const value = e.target.value;
            set_pending(prev => {
                const result = {...prev, [prop]: value};
                if (prop == 'country') {
                    const origin_country = value == source?.country;
                    result.phone = origin_country ? source?.phone : '';
                    result.state = origin_country ? source?.state : '';
                    result.city = origin_country ? source?.city : '';
                }
                if (prop == 'state') {
                    const origin_state = value == source?.state;
                    result.city = origin_state ? source?.city : '';
                }
                return result;
            });
        }
    }, [phone_mask, source]);
    const on_apply = useCallback(() => {
        set_dialog_content({type: 'loading', label: 'Loading...'});
        // @ts-ignore
        let promise = is_editing ? edit_record(source, pending) : create_record(pending);

        promise?.then(x => {
            set_dialog_content({
                type: 'success',
                label: is_editing ? 'Editing' : 'Creating' + ' record success',
                message: 'Record was ' + is_editing ? 'updated' : 'created',
                on_success: () => on_confirm(x, is_editing ? 'edit' : 'create'),
            });
        }).catch(e => {
            if (e.path) {
                set_errors({[e.path]: e.message});
                set_dialog_content(undefined);
            } else {
                set_dialog_content({
                    type: 'error',
                    label: 'Server error',
                    message: e.message,
                });
            }
        });
    }, [pending, on_confirm, source]);


    return <Box sx={{display: 'flex', justifyContent: 'center', margin: '24px'}}>
        <Dialog open={!!dialog_content}>
            <DialogTitle>
                <h3>{dialog_content?.label || ''}</h3>
            </DialogTitle>
            <DialogContent>
                {dialog_content?.type == 'loading' &&
                    <CircularProgress sx={{display: 'flex', justifyContent: 'center', margin: '24px'}}/>}
                {dialog_content?.type != 'loading' && !!dialog_content?.message &&
                    <Typography>{dialog_content.message}</Typography>
                }
            </DialogContent>
            <DialogActions>
                <Stack direction='row' spacing='8px'>
                    {!!dialog_content?.on_success &&
                        <Button variant='contained'
                                onClick={() => {
                                    set_dialog_content(undefined);
                                    dialog_content?.on_success?.();
                                }}>
                            Confirm
                        </Button>
                    }
                    {dialog_content?.type != 'loading' &&
                        <Button onClick={() => set_dialog_content(undefined)}>Close</Button>
                    }
                </Stack>
            </DialogActions>
        </Dialog>
        <FormControl component={Stack} direction='column' spacing='8px' padding='12px'>
            <TextField
                id="f_name"
                label="Name"
                error={!!errors?.name && !!pending?.name}
                value={pending?.name || ''}
                onChange={change_field_fn('name')}
                helperText={errors?.name || 'enter your name'}
                variant="standard"
            />
            <TextField
                id="f_email"
                label="Email"
                error={!!errors?.email && !!pending?.email}
                value={pending?.email || ''}
                onChange={change_field_fn('email')}
                helperText={errors?.email || 'enter your email'}
                variant="standard"
            />
            {!is_editing &&
                <TextField
                    id="f_email"
                    label="Repeate email"
                    error={!!errors?.email2 && !!pending?.email2}
                    value={pending?.email2 || ''}
                    onChange={change_field_fn('email2')}
                    helperText={errors?.email2 || 'confirm your email'}
                    variant="standard"
                />
            }
            <TextField
                id="f_country"
                select
                label="Country"
                error={!!errors?.country && !!pending?.country}
                value={pending?.country || ''}
                onChange={change_field_fn('country')}
                helperText={errors?.country || 'select country'}
                variant="standard">
                {countries.map(x => <MenuItem key={x.isoCode} value={x.isoCode}>
                    {x.name}
                </MenuItem>)}
            </TextField>
            <TextField
                id="f_state"
                select
                label="State"
                disabled={!pending?.country || !states.length}
                error={!!errors?.state && !!pending?.state}
                value={pending?.state || ''}
                onChange={change_field_fn('state')}
                helperText={errors?.state || 'select state'}
                variant="standard">
                {states.map(x => <MenuItem key={x.isoCode} value={x.isoCode}>
                    {x.name}
                </MenuItem>)}
            </TextField>
            <TextField
                id="f_city"
                select
                label="City"
                disabled={!pending?.country || !cities.length}
                error={!!errors?.city && !!pending?.city}
                value={pending?.city || ''}
                onChange={change_field_fn('city')}
                helperText={errors?.city || 'select city'}
                variant="standard">
                {cities.map(x => <MenuItem key={x.name} value={x.name}>
                    {x.name}
                </MenuItem>)}
            </TextField>
            <InputMask mask={phone_mask}
                       value={pending?.phone || ''}
                       disabled={!pending?.country}
                       onChange={change_field_fn('phone')}>
                {
                    // @ts-ignore
                    () => <TextField
                        label="Phone"
                        error={!!errors?.phone && !!pending?.phone}
                        helperText={errors?.phone || 'enter your phone'}
                        variant="standard"
                    />
                }
            </InputMask>
            <Button variant='contained'
                    onClick={() => on_apply()}
                    disabled={!can_apply}>
                {is_editing ? 'Apply' : 'Create'}
            </Button>
        </FormControl>
    </Box>;
}